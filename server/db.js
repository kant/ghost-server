let assert = require('assert');

let pg = require('pg');
let time = require('@expo/time');

let secret = require('./secret');
let testutils = require('./testlib/testutils');

let _testId = null;

function _makeDateString(t) {
  let twoDigits = (n) => ('0' + n).slice(-2);
  return (
    '' +
    (t.getYear() + 1900) +
    [t.getMonth() + 1, t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds()]
      .map(twoDigits)
      .join('')
  );
}

function _makeTestId() {
  let testId = _makeDateString(new Date()) + '_';
  let abc = 'abcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 10; i++) {
    testId += abc.charAt(Math.floor(Math.random() * abc.length));
  }
  return testId;
}

function getTestId() {
  if (!_testId) {
    _testId = _makeTestId();
  }
  return _testId;
}

let _config = {
  ...secret.postgres,
};

// If we are in a test environment, make a copy of the schema
// of production environment and a new database and then give
// it the same schema and then use it
let _dbReady$ = Promise.resolve(process.env.NODE_ENV);
async function databasePreparedAsync() {
  return _dbReady$;
}

if (process.env.NODE_ENV === 'test') {
  console.log("// Using test environment because `process.env.NODE_ENV` is 'test'");

  async function _prepareTestDatabaseAsync() {
    // Sanity check
    assert.strictEqual(process.env.NODE_ENV, 'test');

    // Pick a name for the new database
    let testDatabaseName = secret.postgres.database + '__' + getTestId() + '__test__';

    // Create it
    await testutils.createDatabaseAsync(testDatabaseName);

    // Use it
    _config.database = testDatabaseName;

    // Copy over the schema
    console.log('// Using test database ' + testDatabaseName);
    let schemaSql = await testutils.getProductionDatabaseSchemaAsync();
    let client = new pg.Client(_config);
    await client.connect();
    try {
      await client.query(schemaSql);
      // await client.query(`INSERT INTO "env" ("var", "value") VALUES ('env', 'test') ON CONFLICT ("var") DO UPDATE SET "value" = 'test';`);
    } catch (e) {
      console.error('Error setting up schema for test database ' + testDatabaseName);
      throw e;
    } finally {
      await client.end();
    }

    // Now we're ready
    // process.stdout.write(`\n// Test database ready.\n// Using ${_config.database}\n> `);
    process.stdout.write(`\n// Test database ready.\n> `);

    return process.env.NODE_ENV;
  }

  _dbReady$ = _prepareTestDatabaseAsync();
}

let _pool = null;
async function poolAsync() {
  if (_pool === null) {
    await databasePreparedAsync();
    _pool = new pg.Pool(_config);

    // the pool with emit an error on behalf of any idle clients
    // it contains if a backend error or network partition happens
    _pool.on('error', (err, client) => {
      console.error('[pg] Unexpected error on idle client', err);
      // process.exit(-1);
    });
  }
  return _pool;
}

async function queryAsync(query, values, opts) {
  opts = opts || {};
  let tk = time.start();
  let pool = await poolAsync();
  let client = await pool.connect();
  time.end(tk, 'db-connect', { threshold: 10 });

  // Construct message for logging this
  let logLimit = opts.logLimit || 256;
  let message = query.substr(0, logLimit);
  if (query.length > logLimit) {
    message += '...';
  }
  if (values && !opts.dontLogValues) {
    message += ' ' + JSON.stringify(values.slice(0, 4));
    if (message.length > logLimit * 2) {
      message = message.substr(0, logLimit) + ' ...]';
    }
  }
  message = message.replace(/\s+/g, ' ');

  let tkq = time.start();
  let queryOk = false;
  let queryError = null;
  try {
    let result = await client.query(query, values);
    queryOk = true;
    return result;
  } catch (e) {
    queryError = e.message;
    message = queryError + '. ' + message;
    throw e;
  } finally {
    time.end(tkq, 'db-query' + (queryOk ? '' : '-error'), { threshold: 0, message });
    client.release();
  }
}

function replacer() {
  let values = [];
  let r = (val) => {
    values.push(val);
    return '$' + values.length;
  };

  r.json = (val) => {
    return r(JSON.stringify(val));
  };

  r.inList = (list) => {
    return '(' + list.map(r).join(', ') + ')';
  };

  r.values = () => {
    return values;
  };

  r.queryAsync = async (q, opts) => {
    return await queryAsync(q, r.values(), opts);
  };

  return r;
}

let iq = JSON.stringify;

async function drainPoolAsync() {
  let pool = await poolAsync();
  await pool.end();
}

async function cleanupTestDatabaseAsync() {
  if (process.env.NODE_ENV === 'test') {
    let dbName = _config.database;
    if (dbName.endsWith('__test__')) {
      console.log('Cleaning up test database ' + dbName);

      // First we need to drain this pool and disconnect so we can drop the database
      console.log('Draining pool and ending connections');
      await drainPoolAsync();
      console.log('Connections ended');

      // Now we need to use a connection to the production database to
      // drop the test database
      let { Client } = pg;
      let client = new Client(secret.postgres);
      await client.connect();
      try {
        console.log('Dropping test database ' + dbName);
        let result = await client.query(`DROP DATABASE ${iq(dbName)};`);
        assert.strictEqual(result.command, 'DROP');
      } finally {
        await client.end();
      }
    }
  }
}

module.exports = {
  queryAsync,
  replacer,
  pg,
  iq,
  poolAsync,
  databasePreparedAsync,
  cleanupTestDatabaseAsync,
  drainPoolAsync,
  getTestId,
  _config,
  _pool,
  _dbReady$,
  _makeDateString,
};
